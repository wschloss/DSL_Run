<h1>DSL Run</h1>
<h2>A game where objects are defined by an internal DSL</h2>
<p><i>Walter Schlosser</i></p>
<hr>
<p><i>Requires 'Gosu' gem to run, run 'ruby Main.rb'</i></p>
<hr>
<h2>Inspiration</h2>
<p>One aspect of game design I've read is that the developers should allow the game to be easily modified by team members who are not programming experts.  A good design reads aspects like level layout from external files that are either easy to create, or that can be generated by a level editing tool made for designers.  I also learned about domain specific languages and made a simple one for a school assignment.  I got excited about trying to make a more complex DSL on my own, and decided to mesh this concept with game development so constructing a game is easy for anyone.</p>
<h2>Description
<p>'DSL Run' is a simple run/jump game project I'm working on where the objects and iteractions are defined in an external file, which is really using a Ruby internal DSL.  In this way, it is easy to make a new level/object without having to ever mess around with source code.  The character runs and the spacebar makes him jump.</p>
<p>Some goals I currently have in mind: </p>
<ul>
	<li>Stop constantly talking about how awesome reflection is in Ruby programming</li>
	<li>Try to remove as much of the actual game definition from the code and place in the DSL.  Maybe one day the DSL will be a sort of platformer game engine language.</li>
	<li>Break down the Player module into smaller chunks of functionality to include</li>
	<li>Replace block class with functionality modules that the DSL can put together, just like how the player object is constructed.</li>
	<li>Extract definition of an objects sprite to the DSL</li>
	<li>Fix the horizontal collision detection - sometimes corners are buggy</li>
</ul>
<hr>
<h2>Current state of the DSL</h2>
<p>
	Simple game object definitions are constructed with the make_object function.  This function is passed a name so the object definition can be identified later by the create_object function.  make_object is also passed a block which define its functionality.  Right now, the 'runs' and 'player' commands are available, which make the object run to the right automatically, and defines the object as the main player so it responds to the jump button.
	```ruby
	make_object "player" do
  	  runs
  	  player
	end
	```
	After this definition is made, the create_object function can be used to place this object in the game.  Objects can be passed an x,y value to initialize their position, but it is not required.
	```ruby
	create_object "player"
	```
	Lastly, blocks are still directly generate with the 'create_block' function.  In the future, blocks will be defined and placed in the same way as the player.  The create_block function takes an x, width, and height value to define its placement and size (in number of tiles).
	```ruby
	create_block 30, 10, 2
	```
</p>

